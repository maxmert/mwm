var archives, async, dialog, fs, log, maxmertkit, mustache, pack, path, request, templates, write, _;

pack = require('../package.json');

templates = require('../templates.json');

async = require('async');

request = require('superagent');

fs = require('fs');

path = require('path');

dialog = require('commander');

_ = require('underscore');

mustache = require('mustache');

log = require('./logger');

archives = require('./archives');

maxmertkit = require('./maxmertkit');

exports.init = function(options) {
  var fileName, mjson, paramsFileName,
    _this = this;
  fileName = '_index.sass';
  paramsFileName = '_params.sass';
  mjson = maxmertkit.json();
  return async.series({
    widget: function(callback) {
      write('_imports.sass', "/* Generated with mwm – maxmertkit widget manager */\n", callback);
      write(fileName, mustache.render(templates.widget, mjson), callback);
      return write(paramsFileName, mustache.render(templates.params, mjson), callback);
    }
  }, function(err, res) {
    if (err != null) {
      log.error("An error while initialized widget.");
      return process.stdin.destroy();
    } else {
      return process.stdin.destroy();
    }
  });
};

exports.publish = function(options) {
  var mjson,
    _this = this;
  mjson = maxmertkit.json();
  return async.series({
    widget: function(callback) {
      return archives.pack('.', callback);
    },
    password: function(callback) {
      return dialog.password('\nEnter your password: ', function(password) {
        return callback(null, password);
      });
    }
  }, function(err, res) {
    var packFile;
    if (err != null) {
      log.error("Publishing canceled.");
      return process.stdin.destroy();
    } else {
      packFile = path.join('.', "" + mjson.name + "@" + mjson.version + ".tar");
      return request.post("" + pack.homepage + "/widgets/" + mjson.name + "/" + mjson.version).set('X-Requested-With', 'XMLHttpRequest').attach(path.basename(packFile), packFile).field('password', res.password).field('name', mjson.name).field('version', mjson.version).field('username', mjson.author).end(function(res) {
        if (res.ok) {
          log.requestSuccess("widget " + mjson.name + "@" + mjson.version + " successfully published.");
          return process.stdin.destroy();
        } else {
          log.requestError(res.body.msg, 'ERRR', res.status);
          return process.stdin.destroy();
        }
      });
    }
  });
};

exports.install = function(pth, list, callback) {
  var arr;
  arr = [];
  _.each(list, function(version, name) {
    return arr.push({
      name: name,
      version: version
    });
  });
  return async.every(arr, function(widget, callback) {
    return process.nextTick(function() {
      var _this = this;
      return request.get("" + pack.homepage + "/widgets/" + widget.name + "/" + widget.version).set('X-Requested-With', 'XMLHttpRequest').end(function(res) {
        var nme, result, value, _ref;
        if (!res.ok) {
          log.requestError(res.body.msg, 'ERRR', res.status);
          return callback(true, null);
        } else {
          if (!(typeof result !== "undefined" && result !== null)) {
            result = res.body;
          } else {
            _ref = res.body;
            for (nme in _ref) {
              value = _ref[nme];
              result[nme] += "\t" + value;
            }
          }
          log.requestSuccess("Widget " + widget.name + "@" + widget.version + " successfully downloaded.");
          return callback(null, result);
        }
      });
    });
  }, function(err, res) {
    if (err != null) {
      return process.stdin.destroy();
    } else {
      if (!(res != null)) {
        return process.stdin.destroy();
      } else {

      }
    }
  });
};

write = function(file, data, callback) {
  return fs.writeFile(file, data, function(err) {
    if (err) {
      log.error("initializing – " + err + ".");
      return callback(err, null);
    } else {
      log.success("file " + file + " successfully created.");
      return callback(null, data);
    }
  });
};

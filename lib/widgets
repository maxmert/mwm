var async, dialog, fs, fstream, log, mustache, ncp, pack, path, request, rmdirSyncForce, tar, templates;

pack = require('../package.json');

templates = require('../templates.json');

request = require('superagent');

dialog = require('commander');

path = require('path');

log = require('./logger');

async = require('async');

tar = require('tar');

mustache = require('mustache');

fs = require('fs');

ncp = require('ncp').ncp;

fstream = require('fstream');

/*
Returns the montent of maxmertkit.json file
*/


exports.maxmertkit = function() {
  var json, rawjson;
  rawjson = fs.readFileSync(path.join('.', pack.maxmertkit));
  if (!(rawjson != null)) {
    log.error("couldn\'t read " + pack.maxmertkit + " file.");
    return process.stdin.destroy();
  } else {
    return json = JSON.parse(rawjson);
  }
};

/*
Initializing new widget or theme in current directory
*/


exports.init = function(options) {
  var types,
    _this = this;
  types = ['widget', 'theme'];
  return async.series({
    type: function(callback) {
      return dialog.choose(types, function(i) {
        return callback(null, types[i]);
      });
    },
    name: function(callback) {
      var defaultPkgName;
      defaultPkgName = 'test';
      return dialog.prompt("name: (test) ", function(pkgName) {
        if (pkgName === '') {
          pkgName = defaultPkgName;
        }
        return callback(null, pkgName);
      });
    },
    version: function(callback) {
      var defaultVersion;
      defaultVersion = '0.0.0';
      return dialog.prompt("version: (0.0.0) ", function(version) {
        if (version === '') {
          version = defaultVersion;
        }
        return callback(null, version);
      });
    },
    description: function(callback) {
      return dialog.prompt("description: ", function(description) {
        return callback(null, description);
      });
    },
    repository: function(callback) {
      return dialog.prompt("repository: ", function(repository) {
        return callback(null, repository);
      });
    },
    author: function(callback) {
      return dialog.prompt("author: ", function(author) {
        return callback(null, author);
      });
    },
    license: function(callback) {
      var defaultLicense;
      defaultLicense = 'BSD';
      return dialog.prompt("license: (BSD) ", function(license) {
        if (license === '') {
          license = defaultLicense;
        }
        return callback(null, license);
      });
    }
  }, function(err, maxmertkitjson) {
    return _this.writeConfirm(maxmertkitjson, options);
  });
};

/*
Confirm writing json to the maxmertkit.json file
*/


exports.writeConfirm = function(json, options) {
  var _this = this;
  return dialog.confirm("Is everything correct? \n\n " + (JSON.stringify(json, null, 4)) + "\n-> ", function(ok) {
    console.log("");
    if (!ok) {
      log.error("Initializing canceled");
      return process.stdin.destroy();
    } else {
      return fs.exists(pack.maxmertkit, function(exists) {
        if (!exists) {
          _this.write(json, options);
          return process.stdin.destroy();
        } else {
          log.error("File " + pack.maxmertkit + " already exists.");
          return dialog.confirm("Do you want to overwrite it and all other files in that folder? -> ", function(ok) {
            if (!ok) {
              log.error("initialization canceled.");
              return process.stdin.destroy();
            } else {
              _this.write(json, options);
              return process.stdin.destroy();
            }
          });
        }
      });
    }
  });
};

/*
Writing json to the maxmertkit.json file
Init other files
*/


exports.write = function(json, options) {
  fs.writeFile(pack.maxmertkit, JSON.stringify(json, null, 4), function(err) {
    if (err) {
      log.error("initializing â€“ " + err + ".");
    }
    return log.success("file " + pack.maxmertkit + " successfully created.");
  });
  return fs.writeFile('_index.sass', mustache.render(templates.widget, json), function(err) {
    if (err != null) {
      log.error("Coluldn\'t initialize _index.sass file.");
      return process.stdin.destroy();
    } else {
      return log.success("file _index.sass successfully created.");
    }
  });
};

rmdirSyncForce = function(path) {
  var file, fileStats, files, filesLength, _i, _len;
  if (path[path.length - 1] !== '/') {
    path = path + '/';
  }
  files = fs.readdirSync(path);
  filesLength = files.length;
  if (filesLength) {
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      fileStats = fs.statSync(path + file);
      if (fileStats.isFile()) {
        fs.unlinkSync(path + file);
      }
      if (fileStats.isDirectory()) {
        rmdirSyncForce(path + file);
      }
    }
  }
  return fs.rmdirSync(path);
};

/*
Packing widget or theme in current folder. The folders name should be the same as your package name in maxmertkit.json
*/


exports.pack = function(options, callback) {
  var directoryName, fileName, maxmertkitjson,
    _this = this;
  maxmertkitjson = this.maxmertkit();
  if (path.basename(path.resolve('.')) === ("" + maxmertkitjson.name)) {
    directoryName = "/tmp/" + maxmertkitjson.name;
    fileName = "" + maxmertkitjson.name + "@" + maxmertkitjson.version + ".tar";
    return async.series({
      rmdir: function(callback) {
        return fs.exists(directoryName, function(exists) {
          if (exists) {
            rmdirSyncForce(directoryName, callback);
          }
          return callback(null, 'yes');
        });
      },
      dir: function(callback) {
        return fs.mkdir(directoryName, 0x1ff, function() {
          return callback(null, directoryName);
        });
      },
      store: function(callback) {
        return _this.store(callback);
      },
      precompile: function(callback) {
        return _this.precompile(directoryName, callback);
      },
      pack: function(callback) {
        return fstream.Reader({
          path: directoryName,
          type: 'Directory'
        }).pipe(tar.Pack({})).pipe(fstream.Writer("/tmp/" + fileName).on('close', function(err) {
          if (err != null) {
            log.error('Failed to create package.');
            if (!(callback != null)) {
              return process.stdin.destroy();
            } else {
              return callback(err, fileName);
            }
          } else {
            return callback(null, fileName);
          }
        }));
      },
      restore: function(callback) {
        return _this.restore(fileName, callback);
      }
    }, function(err, res) {
      log.success("Finished to create package");
      if (!(callback != null)) {
        return process.stdin.destroy();
      } else {
        return callback(null, fileName);
      }
    });
  } else {
    log.error("The folders name (" + (path.basename(path.resolve('.'))) + ") should be the same as your package name in maxmertkit.json (" + maxmertkitjson.name + ").");
    if (!(callback != null)) {
      return process.stdin.destroy();
    } else {
      return callback(false, fileName);
    }
  }
};

/*
Store current folder in /tmp/ folder.
*/


exports.store = function(callback) {
  var directoryName, maxmertkitjson;
  maxmertkitjson = this.maxmertkit();
  directoryName = "/tmp/" + maxmertkitjson.name;
  return ncp('.', directoryName, {
    filter: function(name) {
      var currentName;
      currentName = path.relative('.', name).split(path.sep)[0];
      if (currentName.charAt(0) === '.' || path.relative('.', name).indexOf('dependences') !== -1 || path.relative('.', name).indexOf('.tar') !== -1) {
        return false;
      } else {
        return true;
      }
    }
  }, function(err) {
    if (err) {
      log.error("Failed to store current directory to " + directoryName + " folder. Do you have permissions?");
      if (!(callback != null)) {
        return process.stdin.destroy();
      } else {
        return callback(err, directoryName);
      }
    } else {
      if (!(callback != null)) {
        return process.stdin.destroy();
      } else {
        return callback(null, directoryName);
      }
    }
  });
};

/*
Restore package from /tmp folder to the current folder
*/


exports.restore = function(fileName, callback) {
  return fs.readFile(path.join('/tmp/', fileName), function(err, data) {
    if (err != null) {
      log.error("Failed to restore " + fileName + " from /tmp folder. Maybe there is no such file or folder.");
      if (!(callback != null)) {
        return process.stdin.destroy();
      } else {
        return callback(err, fileName);
      }
    } else {
      return fs.writeFile(path.join('.', fileName), data, function(err) {
        if (err != null) {
          log.error("Failed to restore " + fileName + " from /tmp folder. Maybe you do not have permissions to write in current folder.");
          if (!(callback != null)) {
            return process.stdin.destroy();
          } else {
            return callback(err, fileName);
          }
        } else {
          if (!(callback != null)) {
            return process.stdin.destroy();
          } else {
            return callback(null, fileName);
          }
        }
      });
    }
  });
};

/*
Unpacking widget or theme in current folder.
*/


exports.unpack = function(fileName, callback) {
  var maxmertkitjson;
  maxmertkitjson = this.maxmertkit();
  fileName = "" + maxmertkitjson.name + "@" + maxmertkitjson.version + ".tar";
  return fs.createReadStream(path.join('.', fileName)).pipe(tar.Extract({
    path: '.'
  })).on('error', function(err) {
    log.error("Failed to unpack " + fileName + " width error:\n" + err);
    if (!(callback != null) || typeof callback === 'object') {
      return process.stdin.destroy();
    } else {
      return callback(err, fileName);
    }
  }).on('end', function() {
    log.success("File " + fileName + " unpacked.");
    if (!(callback != null) || typeof callback === 'object') {
      return process.stdin.destroy();
    } else {
      return callback(null, fileName);
    }
  });
};

/*
Prepare main file of widget for publishing
*/


exports.precompile = function(directoryName, callback) {
  var fileName, maxmertkitjson;
  maxmertkitjson = this.maxmertkit();
  fileName = path.join(directoryName, '_index.sass');
  return async.series({
    widget: function(callback) {
      return fs.readFile(fileName, function(err, data) {
        if (err != null) {
          callback(err, null);
        }
        return callback(null, data);
      });
    }
  }, function(err, data) {
    var result;
    if (err != null) {
      log.error("Failed to precompile " + fileName + ".");
      if (!(callback != null)) {
        return process.stdin.destroy();
      } else {
        return callback(err, fileName);
      }
    } else {
      maxmertkitjson.data = data.widget;
      result = mustache.render(templates.widgetFinal, maxmertkitjson);
      return fs.writeFile(fileName, result, function(err) {
        if (err != null) {
          log.error("Failed to precompile " + fileName + ".");
          if (!(callback != null)) {
            return process.stdin.destroy();
          } else {
            return callback(err, fileName);
          }
        } else {
          if (!(callback != null)) {
            return process.stdin.destroy();
          } else {
            return callback(null, fileName);
          }
        }
      });
    }
  });
};

/*
Install all dependences
*/


exports.install = function() {
  var dependences, deps, maxmertkitjson, name, version,
    _this = this;
  maxmertkitjson = this.maxmertkit();
  if (!(maxmertkitjson.dependences != null) || maxmertkitjson.dependences.length <= 0) {
    log.error("Couldn\'t install your dependences because you don\'t have any.");
    return process.stdin.destroy();
  } else {
    deps = maxmertkitjson.dependences;
    dependences = [];
    for (name in deps) {
      version = deps[name];
      dependences.push({
        name: name,
        version: version
      });
    }
    return async.series({
      exists: function(callback) {
        return async.every(dependences, _this.onServerIsExistsVersion, function(err, results) {
          if (err) {
            return callback(err, null);
          } else {
            return callback(null, true);
          }
        });
      },
      get: function(callback) {
        return async.every(dependences, _this.onServerGetDependencyWidget, function(err, results) {
          if (err) {
            return callback(err, null);
          } else {
            return callback(null, true);
          }
        });
      }
    }, function(err, data) {
      if (err != null) {
        console.log('\n');
        log.error("Installation aborted because some widgets or their versions don\'t exists on server.");
        return process.stdin.destroy();
      }
    });
  }
};

/*
Get dependency from server
*/


exports.onServerGetDependencyWidget = function(widget, callback) {
  var req, writer;
  writer = fs.createWriteStream("/tmp/" + widget.name + "@" + widget.version + ".tar");
  req = request.get("" + pack.homepage + "/widgets/" + widget.name + "/" + widget.version + "/tar").set('X-Requested-With', 'XMLHttpRequest').set('Accept', 'application/tar');
  return req.pipe(writer);
};

/*
Check if widget or theme is exists
*/


exports.onServerIsExistsApp = function(options, callback) {
  var widget;
  widget = this.maxmertkit();
  if ((options.version != null) && options.version === true) {
    return this.onServerIsExistsVersion(widget, callback);
  } else {
    return this.onServerIsExists(widget, callback);
  }
};

exports.onServerIsExists = function(widget, callback) {
  return request.get("" + pack.homepage + "/widgets/" + widget.name).set('X-Requested-With', 'XMLHttpRequest').end(function(res) {
    if (res.ok) {
      log.requestSuccess(res.body.msg, 'OK', res.status);
      if (!(callback != null) || typeof callback === 'object') {
        return process.stdin.destroy();
      } else {
        return callback(null, widget.name);
      }
    } else {
      log.requestError(res.body.msg, 'ERRR', res.status);
      if (!(callback != null) || typeof callback === 'object') {
        return process.stdin.destroy();
      } else {
        return callback(true, widget.name);
      }
    }
  });
};

/*
Check if widget or theme with current version is exists
*/


exports.onServerIsExistsVersionApp = function(options, callback) {
  var widget;
  widget = this.maxmertkit();
  return this.onServerIsExistsVersion(widget, callback);
};

exports.onServerIsExistsVersion = function(widget, callback) {
  var _this = this;
  return async.series({
    exists: function(callback) {
      return exports.onServerIsExists(widget, callback);
    }
  }, function(err, res) {
    if (err) {
      if (!(callback != null) || typeof callback === 'object') {
        return process.stdin.destroy();
      } else {
        return callback(err, widget.name);
      }
    } else {
      return request.get("" + pack.homepage + "/widgets/" + widget.name + "/" + widget.version).set('X-Requested-With', 'XMLHttpRequest').end(function(res) {
        if (res.ok) {
          log.requestSuccess(res.body.msg, 'OK', res.status);
          if (!(callback != null) || typeof callback === 'object') {
            return process.stdin.destroy();
          } else {
            return callback(null, widget.name);
          }
        } else {
          log.requestError(res.body.msg, 'ERRR', res.status);
          if (!(callback != null) || typeof callback === 'object') {
            return process.stdin.destroy();
          } else {
            return callback(true, widget.name);
          }
        }
      });
    }
  });
};

/*
Publish current version of widget or theme
*/


exports.onServerPublish = function(options, callback) {
  var fileName, widget,
    _this = this;
  widget = this.maxmertkit();
  if (!(widget.dependencies != null)) {
    widget.dependencies = [];
  }
  fileName = "" + widget.name + "@" + widget.version + ".tar";
  return async.series({
    pack: function(callback) {
      return _this.pack(options, callback);
    },
    password: function(callback) {
      return dialog.password('\nEnter your password: ', function(password) {
        return callback(null, password);
      });
    }
  }, function(err, res) {
    if (err) {
      log.error("Could not publish widget.");
      if (!(callback != null) || typeof callback === 'object') {
        return process.stdin.destroy();
      } else {
        return callback(err, widget.name);
      }
    } else {
      return request.post("" + pack.homepage + "/widgets/" + widget.name + "/" + widget.version + "/publish").set('X-Requested-With', 'XMLHttpRequest').attach('pack', fileName).field('packName', res.pack).field('name', widget.name).field('version', widget.version).field('password', res.password).field('username', widget.author).end(function(res) {
        if (res.ok) {
          log.requestSuccess("widget " + widget.name + "@" + widget.version + " successfully published.");
          return fs.unlink("" + widget.name + "@" + widget.version + ".tar", function(err) {
            if (!(callback != null) || typeof callback === 'object') {
              return process.stdin.destroy();
            } else {
              return callback(null, widget.name);
            }
          });
        } else {
          log.requestError(res.body.msg, 'ERRR', res.status);
          return fs.unlink("" + widget.name + "@" + widget.version + ".tar", function(err) {
            if (!(callback != null) || typeof callback === 'object') {
              return process.stdin.destroy();
            } else {
              return callback(true, widget.name);
            }
          });
        }
      });
    }
  });
};

/*
Unpublish current version of widget or theme
*/


exports.onServerUnpublish = function(options, callback) {
  var fileName, widget,
    _this = this;
  widget = this.maxmertkit();
  fileName = "" + widget.name + "@" + widget.version + ".tar";
  return async.series({
    password: function(callback) {
      return dialog.password('\nEnter your password: ', function(password) {
        return callback(null, password);
      });
    }
  }, function(err, res) {
    if (err) {
      log.error("Could not unpublish widget.");
      if (!(callback != null) || typeof callback === 'object') {
        return process.stdin.destroy();
      } else {
        return callback(err, widget.name);
      }
    } else {
      return request.del("" + pack.homepage + "/widgets/" + widget.name + "/" + widget.version).set('X-Requested-With', 'XMLHttpRequest').field('packName', fileName).field('name', widget.name).field('version', widget.version).field('password', res.password).field('username', widget.author).end(function(res) {
        if (res.ok) {
          log.requestSuccess("widget " + widget.name + "@" + widget.version + " successfully unpublished.");
          if (!(callback != null) || typeof callback === 'object') {
            return process.stdin.destroy();
          } else {
            return callback(null, widget.name);
          }
        } else {
          log.requestError(res.body.msg, 'ERRR', res.status);
          if (!(callback != null) || typeof callback === 'object') {
            return process.stdin.destroy();
          } else {
            return callback(true, widget.name);
          }
        }
      });
    }
  });
};

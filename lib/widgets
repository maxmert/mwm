var async, dialog, fs, fstream, log, ncp, pack, path, request, tar;

pack = require('../package.json');

request = require('superagent');

dialog = require('commander');

path = require('path');

log = require('./logger');

async = require('async');

tar = require('tar');

fs = require('fs');

ncp = require('ncp').ncp;

fstream = require('fstream');

/*
Returns the montent of maxmertkit.json file
*/


exports.maxmertkit = function() {
  var json, rawjson;
  rawjson = fs.readFileSync(path.join('.', pack.maxmertkit));
  if (!(rawjson != null)) {
    log.error("couldn\'t read " + pack.maxmertkit + " file.");
    return process.stdin.destroy();
  } else {
    return json = JSON.parse(rawjson);
  }
};

/*
Initializing new widget or theme in current directory
*/


exports.init = function(options) {
  var types,
    _this = this;
  types = ['widget', 'theme'];
  return async.series({
    type: function(callback) {
      return dialog.choose(types, function(i) {
        return callback(null, types[i]);
      });
    },
    name: function(callback) {
      var defaultPkgName;
      defaultPkgName = 'test';
      return dialog.prompt("name: (test) ", function(pkgName) {
        if (pkgName === '') {
          pkgName = defaultPkgName;
        }
        return callback(null, pkgName);
      });
    },
    version: function(callback) {
      var defaultVersion;
      defaultVersion = '0.0.0';
      return dialog.prompt("version: (0.0.0) ", function(version) {
        if (version === '') {
          version = defaultVersion;
        }
        return callback(null, version);
      });
    },
    description: function(callback) {
      return dialog.prompt("description: ", function(description) {
        return callback(null, description);
      });
    },
    repository: function(callback) {
      return dialog.prompt("repository: ", function(repository) {
        return callback(null, repository);
      });
    },
    author: function(callback) {
      return dialog.prompt("author: ", function(author) {
        return callback(null, author);
      });
    },
    license: function(callback) {
      var defaultLicense;
      defaultLicense = 'BSD';
      return dialog.prompt("license: (BSD) ", function(license) {
        if (license === '') {
          license = defaultLicense;
        }
        return callback(null, license);
      });
    }
  }, function(err, maxmertkitjson) {
    return _this.writeConfirm(maxmertkitjson, options);
  });
};

/*
Confirm writing json to the maxmertkit.json file
*/


exports.writeConfirm = function(json, options) {
  var _this = this;
  return dialog.confirm("Is everything correct? \n\n " + (JSON.stringify(json, null, 4)) + "\n-> ", function(ok) {
    console.log("");
    if (!ok) {
      log.error("Initializing canceled");
      return process.stdin.destroy();
    } else {
      return fs.exists(pack.maxmertkit, function(exists) {
        if (!exists) {
          _this.write(json, options);
          return process.stdin.destroy();
        } else {
          log.error("File " + pack.maxmertkit + " already exists.");
          return dialog.confirm("Do you want to overwrite it? -> ", function(ok) {
            if (!ok) {
              log.error("initialization canceled.");
              return process.stdin.destroy();
            } else {
              _this.write(json, options);
              return process.stdin.destroy();
            }
          });
        }
      });
    }
  });
};

/*
Writing json to the maxmertkit.json file
*/


exports.write = function(json, options) {
  return fs.writeFile(pack.maxmertkit, JSON.stringify(json, null, 4), function(err) {
    if (err) {
      log.error("initializing â€“ " + err + ".");
    }
    return log.success("file " + pack.maxmertkit + " successfully created.");
  });
};

/*
Packing widget or theme in current folder. The folders name should be the same as your package name in maxmertkit.json
*/


exports.pack = function(options, callback) {
  var directoryName, fileName, maxmertkitjson,
    _this = this;
  maxmertkitjson = this.maxmertkit();
  if (path.basename(path.resolve('.')) === ("" + maxmertkitjson.name)) {
    directoryName = "/tmp/" + maxmertkitjson.name;
    fileName = "" + maxmertkitjson.name + "@" + maxmertkitjson.version + ".tar";
    return async.series({
      dir: function(callback) {
        return fs.mkdir(directoryName, 0x1ff, function() {
          return callback(null, directoryName);
        });
      },
      store: function(callback) {
        return _this.store(callback);
      },
      pack: function(callback) {
        return fstream.Reader({
          path: directoryName,
          type: 'Directory'
        }).pipe(tar.Pack({})).pipe(fstream.Writer("/tmp/" + fileName).on('close', function(err) {
          if (err != null) {
            log.error('Failed to create package.');
            if (!(callback != null)) {
              return process.stdin.destroy();
            } else {
              return callback(err, directoryName);
            }
          } else {
            return callback(null, directoryName);
          }
        }));
      },
      restore: function(callback) {
        return _this.restore(fileName, callback);
      }
    }, function(err, res) {
      return log.success("Finished to create package");
    });
  } else {
    return log.error("The folders name (" + (path.basename(path.resolve('.'))) + ") should be the same as your package name in maxmertkit.json (" + maxmertkitjson.name + ").");
  }
};

/*
Store current folder in /tmp/ folder.
*/


exports.store = function(callback) {
  var directoryName, maxmertkitjson;
  maxmertkitjson = this.maxmertkit();
  directoryName = "/tmp/" + maxmertkitjson.name;
  return ncp('.', directoryName, {
    filter: function(name) {
      var currentName;
      currentName = path.relative('.', name).split(path.sep)[0];
      if (currentName.charAt(0) === '.' || path.relative('.', name).indexOf('dependences') !== -1) {
        return false;
      } else {
        return true;
      }
    }
  }, function(err) {
    if (err) {
      log.error("Failed to store current directory to " + directoryName + " folder. Do you have permissions?");
      if (!(callback != null)) {
        return process.stdin.destroy();
      } else {
        return callback(err, directoryName);
      }
    } else {
      if (!(callback != null)) {
        return process.stdin.destroy();
      } else {
        return callback(null, directoryName);
      }
    }
  });
};

/*
Restore package from /tmp folder to the current folder
*/


exports.restore = function(fileName, callback) {
  return fs.readFile(path.join('/tmp/', fileName), function(err, data) {
    if (err != null) {
      log.error("Failed to restore " + fileName + " from /tmp folder. Maybe there is no such file or folder.");
      if (!(callback != null)) {
        return process.stdin.destroy();
      } else {
        return callback(err, fileName);
      }
    } else {
      return fs.writeFile(path.join('.', fileName), data, function(err) {
        if (err != null) {
          log.error("Failed to restore " + fileName + " from /tmp folder. Maybe you do not have permissions to write in current folder.");
          if (!(callback != null)) {
            return process.stdin.destroy();
          } else {
            return callback(err, fileName);
          }
        } else {
          if (!(callback != null)) {
            return process.stdin.destroy();
          } else {
            return callback(null, fileName);
          }
        }
      });
    }
  });
};

/*
Unpacking widget or theme in current folder.
*/


exports.unpack = function(fileName, callback) {
  var file, maxmertkitjson, zip, zipEntries;
  maxmertkitjson = this.maxmertkit();
  file = fileName || ("" + maxmertkitjson.name + "@" + maxmertkitjson.version + ".zip");
  zip = new admZip(file);
  zipEntries = zip.getEntries();
  return console.log(zipEntries);
};

/*
Check if widget or theme is exists
*/


exports.onServerIsExists = function(options, callback) {
  var widget;
  widget = this.maxmertkit();
  return request.get("" + pack.homepage + "/widgets/" + widget.name).set('X-Requested-With', 'XMLHttpRequest').end(function(res) {
    if (res.ok && res.status !== 500 && res.status !== 404) {
      if (res.body.done) {
        log.success("widget with name " + widget.name + " exists.");
        if (!(callback != null)) {
          return process.stdin.destroy();
        } else {
          return callback(null, fileName);
        }
      } else {
        log.error("widget with name " + widget.name + " does not exists.");
        if (!(callback != null)) {
          return process.stdin.destroy();
        } else {
          return callback(true, fileName);
        }
      }
    }
  });
};
